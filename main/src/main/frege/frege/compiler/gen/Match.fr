{- «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»

    Copyright © 2011 - 2015, Ingo Wechsung
    All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, are permitted provided that the following
    conditions are met:

        Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

        Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution. Neither the name of the copyright holder
        nor the names of its contributors may be used to endorse or
        promote products derived from this software without specific
        prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
    THE POSSIBILITY OF SUCH DAMAGE.

    «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•» -}

{--
    Java code generation for the frege compiler

    This package deals with pattern matching and @case@ statements.
 -}


package frege.compiler.gen.Match where


import frege.Prelude hiding(apply, <+>)
import Data.TreeMap as TM(TreeMap, values, keys, each, insert, lookup)
import Data.List as DL(sortBy, partitioned)

import  Compiler.enums.Literals

import  Compiler.types.Strictness
import  Compiler.types.JTypes
-- import  Compiler.types.JNames
import  Compiler.types.QNames
import  Compiler.types.Types
import  Compiler.types.Patterns
import  Compiler.types.Expression
import  Compiler.types.ConstructorField
import  Compiler.types.Symbols
import  Compiler.types.Global as G

import  Compiler.common.Mangle
import  Compiler.common.Errors as E()

import  Compiler.classes.Nice

import frege.compiler.Utilities     as U() 
import frege.lib.PP(text, <>)  
import frege.compiler.Transform     as T(patternStrictness)
import frege.compiler.Typecheck     as TY()

import frege.compiler.gen.Util       as GU 
import frege.compiler.gen.Bindings   as GB
import frege.compiler.gen.Const      as GC

infixr 6 `<>`

{--
  * [usage] @match assert pattern bind continuation bindings@
  * [returns] a list of java statements and an updated binding
  * generate code and/or extend current @bindings@ that performs and/or reflects
  * a match of @pattern@
  * against the java expression in @bind@ and generate the code for a successful match
  * by applying @continuation@ to the extended bindings.
  *
  * Generated code will look like this:
  * > comment
  * > auxiliary local definitions
  * > if (patternmatches) {
  * >           code generated by continuation
  * > }
  * If the @assert@ switch is on, this is the last possible match and
  * an assert statement is generated instead of the if. This is useful in 
  * code like:
  * > case foo of 
  * >   Just bar -> ...
  * >   Nothing -> ...
  * The @Nothing@ does not need matching if @bar@ was irrefutable.
  *
  * There does not have to be an @if@ or any other code at all, for example when
  * the pattern is irrefutable. The code generated by the continuation *must* return,
  * if the control flow reaches the closing brace of the if this will be
  * an indication that the pattern match failed.
  -}
match :: Bool 
            -> Pattern 
            -> Binding 
            -> (TreeMap Symbol Binding -> StG [JStmt]) 
            -> TreeMap Symbol Binding 
            -> StG (Binding, [JStmt])
match assert (PVar {uid,var}) bind cont binds = do
         vsym <- U.findV local
         if vsym.strsig.isStrict then strictVar vsym else lazyVar vsym
     where
         local = Local uid var
         jname g = (U.javaName g local).base
         strictVar vsym = do
             g <- getST
             (rbind, code) <- realize (jname g) (adaptSigma g bind)
             let stmt
                    | var == "_" = code
                    | otherwise  = sComment ("bind strict var " ++ nice (Symbol.name vsym) g
                                         ++ "  to  " ++ show rbind) : code
                 nbinds = insert vsym rbind binds
             rest <- cont nbinds
             stio (rbind, stmt++rest)
         lazyVar vsym = do
             g <- getST
             let nbinds = insert vsym bind binds -- (adaptSigmaWith lazy g bind)
                 comment = "bind lazy var " ++ nice (Symbol.name vsym) g ++ "  to  " ++ show bind
             rest <- cont nbinds
             let stmts = if  var == "_" then rest else sComment comment : rest
             stio (bind, stmts)
 
match assert (p@PAt {pat,uid,var}) bind cont binds = do
        g <- getST
        ps <- T.patternStrictness pat
         -- let patty = patternRMode g pat
        let local = Local uid var
            jname = (U.javaName g local).base
        vsym <- U.findV local
        let comment bind = sComment ("match " 
                        ++ nice p g ++ "::" ++ nicer vsym.typ g 
                        ++ "  with  " ++ show bind)
            -- bs = isStrictJT bind.jtype && isKnownJT bind.jtype
            ss = Strictness.isStrict vsym.strsig
        case (ps.isStrict, ss) of
            (_, true) -> do
                (rbind, code1) <- realize jname (adaptSigma g bind)
                let nbinds = insert vsym rbind binds
                (xbind, code2) <- match assert pat rbind cont nbinds
                stio (xbind, comment rbind: code1++code2)
            -- otherwise we change the type of the argument, i.e. String as Lazy String and then
            -- via Delayed.<String>forced() back
            (true, false) -> do 
                -- (rbind, code1) <- realize "$" (adaptSigma g bind)
                (vbind, code2) <- realize jname (adaptSigma g bind)
                let nbinds = insert vsym vbind binds
                (xbind, code3) <- match assert pat vbind cont nbinds
                stio (xbind, comment vbind: code2++code3)
            (false, false) -> do
                (rbind, code1) <- realize jname bind -- (adaptSigmaWith lazy g bind)
                let nbinds = insert vsym rbind binds
                (xbind, code2) <- match assert pat rbind cont nbinds
                stio (xbind, comment rbind: code1++code2)
        
 
match assert (pat@PLit {kind=LBool, value}) bind cont binds = do
     g <- getST
     body <- cont binds
     let comment = sComment ("match  " ++ nice pat g
                                 ++ "  with  " ++ show bind)
         sbnd = adaptSigma g bind
         jex = if value == "true" then sbnd.jex else JUnop "!" sbnd.jex
         ifc = if assert then JAssert jex : body else [JCond "if" jex body]
     stio (bind, comment:ifc)
 
match assert (pat@PCon {pos,qname,pats}) bind  cont binds = do
         -- g <- getST
         symd <- U.findD qname                   -- forall a.a -> List a -> List a
         symt <- U.findT symd.name.tynm          -- forall a.List a 
         if symt.enum then matchEnum symd symt
             else if symt.product
                 then if symt.newt
                     then matchNew     symd symt 
                     else matchProd    symd symt -- pat bind cont binds
                 else matchVariant symd symt -- pat bind cont binds
     where
         comment g = sComment ("match  " ++ nice pat g
                                 ++ "  with  " ++ show bind)
         -- matchNewt :: Symbol -> Symbol -> StG (Binding, [JStmt])
         -- matchNewt symd symt = match (head pats) bind cont binds
         matchEnum :: Symbol -> Symbol -> StG (Binding, [JStmt])
         matchEnum symd symt = do
             g <- getST
             let sbnd = adaptSigma g bind
             -- (bind, code1) <- realize "$" sbnd
             body  <- cont binds
             let comp = JBin sbnd.jex "==" (JX.static (U.javaName g symd.name)) 
                 ifc  = if assert then JAssert comp : body else [JCond "if" comp body]
             stio (sbnd, comment g : ifc)
 
         matchNew :: Symbol -> Symbol -> StG (Binding, [JStmt])
         matchNew symd symt = do
            g <- getST
            let -- box0    = adaptSigma g bind
                arg     = symd.typ.rho.sigma                  -- first arg of data con
                tree    = U.unifySigma g symt.typ bind.ftype  -- instantiate type args a -> Int
                sig     = U.substSigma tree arg               -- substitute in arg
                -- pretend our binding is the pattern
                box1    = adaptSigma g (newBind g sig bind.jex).{jtype = bind.jtype}
            match assert (head pats) box1 cont binds
        
         matchVariant :: Symbol -> Symbol -> StG (Binding, [JStmt])
         matchVariant symd symt = do
            g <- getST
 
            let box1 = adaptSigma g bind                      -- List Int
                tree = U.unifySigma g symt.typ bind.ftype     -- a -> Int
 
                rho  = U.substRho tree symd.typ.rho           -- Int -> List Int -> List Int
            (boxd, code1) <- realize "$" box1                 -- TList $1 = .....
            -- pss <- mapSt patternStrictness pats
            let datajt = sigmaJT g symt.typ                   -- TList
 
            let  -- smode = any Strictness.isStrict pss
                 cname = if symt.product then "" else conGetter qname   -- _DCons
                 vbind = if symt.product then boxd else
                            Bind boxd.stype boxd.ftype
                                (variantType g datajt symd) -- .{targs = boxd.jtype.targs}
                                (JInvoke (JX.jexmem boxd.jex cname) [])
 
            (varb, code2) <- if symt.product then return (boxd, [])
                             else realize "$" vbind             -- TList.DCons $2 = $1._DCons()
 
            let (_,sigs)  = U.returnType rho               -- [b, List b]
                -- set up the expressions that are to be matched by sub patterns
                pbinds = zipWith (fldBind g varb) (namedFields symd.flds) sigs

            
            -- make sure refutable patterns are matched first so that
            -- evaluation of lazy values that are bound to variables does
            -- not occur before it is sure that the overall match succeeds
            let (zpats, zbinds) = (unzip • reverse • sortBy (comparing (T.patternRefutable g • fst))) 
                            (zip pats pbinds)
            rest <- matches assert zpats zbinds cont binds     
 
            let notnull = JBin varb.jex "!=" (JAtom "null")
                ifn = if symt.product
                        then rest
                        else if assert  then JAssert notnull : rest 
                                        else [JCond "if" notnull rest]
                
            stio (boxd, (comment g : code1) ++ code2 ++ ifn)
 
         matchProd :: Symbol -> Symbol -> StG (Binding, [JStmt])
         matchProd symd symt = matchVariant symd symt   -- for the time being
         
 
match assert (pat@PLit {kind=LString, value}) bind cont binds = do
     g <- getST
     (sbnd,code) <- realize "$" (adaptSigma g bind)
     body <- cont binds
     let comment = sComment ("match  " ++ nice pat g
                                 ++ "  with  " ++ show bind)
         -- sbnd = adaptSigma g bind
         jex = JInvoke (JX.jexmem (JAtom value) "equals") [sbnd.jex]
         ifc = if assert then JAssert jex : body else [JCond "if" jex body]
     stio (sbnd, (comment:code) ++ ifc)
 
match assert (pat@PLit {kind, value}) bind cont binds
     | kind `elem` [LChar, LInt, LLong, LDouble, LFloat] = do
         g <- getST
         (sbnd,code) <- realize "$" (adaptSigma g bind)
         body <- cont binds
         let comment = sComment ("match  " ++ nice pat g
                                     ++ "  with  " ++ show bind)
             jex = JBin (JAtom value) "==" sbnd.jex
             ifc = if assert then JAssert jex : body else [JCond "if" jex body]
         stio (sbnd, (comment:code) ++ ifc)
     | kind == LBig = do
         g <- getST
         (sbnd, code) <- realize "$" (adaptSigma g bind)
         body <- cont binds
         let comment = sComment ("match  " ++ nice pat g
                                     ++ "  with  " ++ show bind)
             -- sbnd = adaptSigma g g bind
             lit = Lit {pos = pat.pos, kind = LBig, value, typ = Just TY.sigInteger}
         jname <- findConst lit
         let xbnd =  Bind{ftype = TY.sigInteger, 
                        stype = nicer TY.sigInteger g, 
                        jtype = sigmaJT g TY.sigInteger, 
                        jex = JStMem{jname, targs = []}}
         let jex = JInvoke (JX.jexmem xbnd.jex "equals") [sbnd.jex]
             ifc = if assert then JAssert jex : body else [JCond "if" jex body]
         stio (sbnd, (comment:code) ++ ifc)
     | kind == LRegex = do
         g <- getST
         (sbnd,code) <- realize "$" (adaptSigma g bind)
         body <- cont binds
 
         let comment = sComment ("match  " ++ nice pat g
                                 ++ "  with  " ++ show bind)
             -- sbnd = adaptSigma g g bind
             lit = Lit {pos = pat.pos, kind = LRegex, value, typ = Just (TY.sigRegex)}
         jname <- findConst lit
         let xbnd = Bind{ftype = TY.sigRegex, 
                        stype = nicer TY.sigRegex g, 
                        jtype = sigmaJT g TY.sigRegex, 
                        jex = JStMem{jname, targs = []}}
 
         let matcher = JInvoke (JX.jexmem xbnd.jex "matcher") [sbnd.jex]
             jex = JInvoke (JX.jexmem matcher "find") []
             ifc = if assert then JAssert jex : body else [JCond "if" jex body]
         stio (sbnd, (comment:code) ++ ifc)
 
match assert (pat@PMat {pos, uid, var, value}) bind cont binds = do
         g <- getST
         vsym <- U.findV (Local uid var)
         (sbnd,code) <- realize "$" (adaptSigma g bind)
         let mjt = sigmaJT g TY.sigMatcher
         let comment = sComment ("match  " ++ nice pat g
                                 ++ "  with  " ++ show bind)
             
             lit = Lit {pos, kind = LRegex, value, typ = Just (TY.sigRegex)}
 
         jname <- findConst lit
         let find = JStMem{jname = jnFind,  targs = []}
         -- let xbnd = Bind{ftype = TY.sigMatcher, stype = nicer TY.sigMatcher g, 
         --                jtype = mjt, 
         --                jex = JStMem{jname, targs = []}}
         let mbnd = Bind{ftype = TY.sigMatcher, stype = nicer TY.sigMatcher g, 
                         jtype = mjt,
                         jex = JInvoke find  [sbnd.jex, JStMem jname []]}
         (mbnd,code2) <- realize (U.javaName g (Local uid var)).base mbnd
         body <- cont (binds.insert vsym mbnd)
 
         let  -- jex = JInvoke (JX.jexmem mbnd.jex "find") []
              jex = JBin{j1 = mbnd.jex, op = "!=", j2 = JAtom "null"}
              ifc = if assert then JAssert jex : body else [JCond "if" jex body]
         stio (sbnd, (comment:code) ++ code2 ++ ifc)
 
match assert (PAnn {pat})    bind cont binds = match assert pat bind cont binds
match assert (PUser {pat})   bind cont binds = match assert pat bind cont binds
match _ pat b c bs = do
     g <- getST
     stio (b, [JError ("match  " ++ nice pat g ++ "  with  " ++ show b)])
 
{--
  * A variant of 'match' that matches the components of a product against a pattern
  *
  * @pat@ must be a constructor application whose constructor is the same
  * as given in @con@
  -}
matchCon assert (PCon {pos,qname, pats}) con bexs cont binds = do
         g <- getST
         sym <- U.findD qname
         if sym.sid != Symbol.sid con
             then do
                 E.fatal pos (text ("matchCon: " ++ nice qname g ++ " against " ++ nice con g))
             else do
                 -- make sure refutable patterns are matched first so that
                 -- realization of strict variables does not occur outside an if
                 ppbs = (reverse • sortBy (comparing (T.patternRefutable g • fst))) (zip pats bexs)
                 matches assert (map fst ppbs) (map snd ppbs) cont binds
matchCon assert pcon con bexs cont binds = error "matchCon: no constructor"

--- Match a list of subpatterns against a list of subexpresssions 
matches assert []     []     cont binds = cont binds
matches assert (p:ps) (b:bs) cont binds = do
         (_, code) <- match assert p b (matches assert ps bs cont) binds
         stio code
matches assert _ _ _ _ = Prelude.error "matches: cannot happen when compiler is sane"
 

{--
    tell at what 'JType' the case expression should best be computed to match pattern

patternRMode g p =
    case p of
        PVar {uid,var} -> case (Local uid var).findit g of
            Just sym -> if sym.strsig.isStrict
                 then strict (sigmaJT g sym.typ)
                 else lazy   (sigmaJT g sym.typ)
            other -> error ("patternRMode: var not found  " ++ nicer p g)
        PAt {pos,uid,var,pat} -> patternRMode g PVar{pos, uid, var}
        PUser {pat, lazy} -> if lazy 
            then GU.lazy   (patternRMode g pat) 
            else GU.strict (patternRMode g pat)
        PLit{kind} -> case kind of
                       LBool -> Nativ "boolean" []
                       LChar -> Nativ "char" []
                       LString -> jtString
                       LInt -> jtInt
                       LBig -> Nativ "java.math.BigInteger" []
                       LLong -> Nativ "long" []
                       LFloat -> Nativ "float" []
                       LDouble -> Nativ "double" []
                       LRegex -> jtString

        PMat {pos} ->jtString
        PAnn {pat} -> patternRMode g pat
        PCon {pos,qname,pats} = case QName.findit qname g of
            Just symd -> case (Symbol.name symd).tynm.findit g of
                Just symt -> sigmaJT g (Symbol.typ symt)
        PConFS {pos} -> error ("patternRMode: found PConFS") 
-}
 
{--
  * [usage] @conGetter qname@
  * [return] the name of the method that gets the variant
  * [example] @conGetter (MName tname "Con")@ evaluates to @"_Con"@
  -}
conGetter (MName tname base) = "_" ++ mangled base
conGetter _ = error "conGetter: no member"
 
 
{--
  * [usage] @variantType g jtype symd@
  * [return] the type of the variant, i.e. @tMaybe.dJust<a>@, if jtype is the jt of the type
  -}
variantType :: Global -> JType -> Symbol -> JType
variantType g jtype symd    -- | traceLn("variantType for " ++ show jtype) || true 
    = jtype.{jname = U.javaName g (Symbol.name symd)}

{--
    Instantiate a field of an algebraic value at a given type.
    
     [value] the (strict) 'Binding' that holds the java expression for the value
     [field] the field in question
     [at] the type this is to be instantiated at
     
    Returns a new binding with the java expression that accesses the field.  
    -}
fldBind :: Global -> Binding -> ConField QName -> Sigma -> Binding
fldBind g value field at  = Bind{
        stype = nicer at g,
        ftype = at, 
        jtype = jty , 
        jex = JExMem{jex=(strictBind value).jex, name=unJust field.name, targs=[]}}
    where jty = GB.argType g field.strict field.typ
